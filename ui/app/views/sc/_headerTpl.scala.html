@(args: msc.ScRenderArgs)(implicit ctx: Context)

@* Верстка полосы заголовка со всеми необходимыми кнопками управления выдачей. *@

@import io.suggest.sc.ScConstants.Header._
@import views.html.sc.stuff._
@import msc._

@* Завернуть указанную верстку в ссылку переключения состояния окошка/панени навигации (слева). *@
@toggleNavScrAnchor()(content: Option[msc.ScJsState] => Html) = {
  @hdr._toggleNavScreenSyncWrapTpl(args)(content)
}

@* Хидер главного экрана *@
@hdr._divTpl( Some(ROOT_DIV_ID) ) {
  style="background-color: #@args.bgColor; border-color: #@args.fgColor";
} {

  <span id="@BTNS_DIV_ID">

    @* Кнопка доступа к панели навигации по узлам сети. При синхронном рендере её нужно скрывать, если панель уже на экране. *@
    @if(!args.syncRender || !args.jsStateOpt.exists(_.isSomethingOpened)) {
      @args.topLeftBtnHtml
    }

    @* Два прямоугольника слева. Вроде бы закрывают панель поиска справа. Нужно срезать её при синхронном рендере, если правая панель закрыта. *@
    @if(!args.syncRender || args.jsStateOpt.exists(_.isSearchScrOpened)) {
      @for(jsState <- args.jsStateOpt) {
        <a href="@args.syncUrl( jsState.copy(searchScrOpenedOpt = None) )">
      }
      @ScHdrBtns.ShowIndex( args.hBtnArgs )
      @if(args.jsStateOpt) {
        </a>
      }
    }

    @* Кнопка с 4-мя квадратиками доступа к поисковой панели справа. По дефолту они всегда отображаются, но скрыты в остальных случаях. *@
    @hdr._tileBtnTpl(args)

  </span>

  @toggleNavScrAnchor() { jsStateOpt =>
    @hdr._logoTpl(args,  withId = true)
  }

  <div class="sm-producer-header_icon">
    @svg._catHeaderIcon( args.fgColor )
  </div>

}
