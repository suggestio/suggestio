@(mad: MAdT, args: blk.RenderArgs, bc: util.blocks.BlocksConf.CommonBlock2T)(implicit ctx: Context)

@* Базовый шаблон тела block'ов версии 2.0. *@

@import views.txt.blocks.common._

@* если true, то нужно рендерить стили инлайново. Иначе -- ссылкой на css. *@
@* Отрендерить одно строковое значение оффера. *@
@renderText(aosfOpt: Option[AOStringField], fid: String, bf: BfText, yoff: Int, offerN: Int, withStyle: Boolean) = {
  @aosfOpt.map { aosf =>
    <div class="@if(args.withEdit){js-mvbl} mvbl-@fid mvbl-@fid-@offerN" @if(args.withEdit) {data-connected-input="ad.offer.offer[@offerN].@fid"}>
      <div class="@fid @fid-@offerN">@Html(aosf.value)</div>
    </div>
    @if(withStyle) {
      <style>
        @Html(_textCss(blk.FieldCssRenderArgs2(
          mad     = mad,
          aovf    = aosf,
          bf      = bf,
          szMult  = args.szMult,
          offerN  = offerN,
          yoff    = yoff,
          fid     = fid
        )).toString.trim)
      </style>
    }
  }
}


@defining( args.inlineStyles || mad.id.isEmpty ) { isStylesInline =>

  @bgImgTpl(mad, bc, args,  cssClass = Some("bg") )

  @if(isStylesInline) {
    <style>@Html(_blockCss( blk.CssRenderArgs(mad, args.szMult) ).toString.trim)</style>
  }

  @mad.offers.map { offer =>

      @renderText(offer.text1, "title", bc.titleBf, yoff = 0, offerN = offer.n, withStyle = isStylesInline)
      @renderText(offer.text2, "descr", bc.descrBf, yoff = 25, offerN = offer.n, withStyle = isStylesInline)

  }

}
