@(bf: BlockAOValueFieldT, bc: BlockConf, bfNameBase: String, af: Form[_], colorWithLabel: Boolean = false)(content: Html)(implicit ctx: Context)

@* Поле для ввода текста: input или textarea в зависимости от обстоятельств. *@
@import ctx._
@import helper._

<label class="ad-block-editor__fieldset_label">@Messages(bc.i18nLabelOf(bf.name)) @bf.offerNopt.map(_ + 1)</label>

<div class="lk-field-w-colorpicker">
  <div class="lk-field-w-colorpicker__left lk-fieldeset_wide">@content</div>

  @if( bf.withFontColor ) {
    <div class="lk-field-w-colorpicker__right">
      @_colorBtnTpl(
        colorField = af(bfNameBase + ".font.color"),
        default    = bf.defaultValue.map(_.font.color),
        withLabel  = colorWithLabel
      )

      @if( bf.withFontSize ) {
        @_fontSizeSelectTpl(bf, bfNameBase, af)
      }

      @* Пример задания полей для координат. *@
      @if( bf.withCoords ) {
        @defining( bfNameBase + ".coords.x" ) { xname =>
          <input type="text" name="@xname" value="@af(xname).value"/>
        }
        @defining( bfNameBase + ".coords.y" ) { yname =>
          <input type="text" name="@yname" value="@af(yname).value"/>
        }
      }

      @* Выравнивание текста. Допустимые значения: l/left/r/right/j/justify/c/center. *@
      @if( bf.withTextAlign ) {
        @defining(bfNameBase + ".font.align") { aname =>
          @aname: <input type="text" name="@aname" value="@af(aname).value"/>
        }
      }

      @if( bf.withFontFamily ) {
        @defining( bfNameBase + ".font.family") { ffname =>
          @ffname: <input type="text" name="@ffname" value="@af(ffname).value"/>
        }
      }
    </div>
  }

</div>